# Обработка выражения

## Преобразование выражения к массиву токенов
Любое корректное выражение состоит из токенов. В проекте выделено 4 типа: число, операция, открывающая и закрывающая скобка
```Go
type TokenType int
const (
	Number TokenType = iota
	BinaryOperation
	CloseBracket
	OpenBracket
)
```

Операция, в свою очередь, также может иметь 4 типа: +, -, *, /. Сложение и вычитание имеют приоритет 1, а умножение и деление - приоритет 2
```Go
type OperationType int
const (
	Plus OperationType = iota
	Minus
	Multiply
	Divide
)

func (t *OperationType) Priority() int {
	switch *t {
	case Plus, Minus:
		return 1
	case Multiply, Divide:
		return 2
	}

	return 0
}
```

Используя полученные типы можно за один "проход" по массиву преобразовать строку в массив токенов

## Создание бинарного дерева
Получив массив токенов, необходимо преобразовать его в бинарное дерево, узлы которого имеют структуру:
```Go
type Node struct {
	Value expr_tokens.Token
	Left  *Node
	Right *Node
}
```

### Алгоритм построения двоичного дерева
1. Если переданный массив имеет лишь один токен - число, значит мы получили "лист" дерева. Необходино записать чило в `Node.Value` и вернуть этот узел
2. Поиск в массиве операции с наименьшим приоритетом. Следует помнить, что если операция находится в скобках, её приоритет возрастает. Таким образом в выражении (2-2)/2+6-9/(1*7) наименьшим прироритетом будет обладать операция "+"
3. Разбить массив на две части: до операции, полученной в пункте 2, и после
4. Выполнить алгоритм, начиная с пункта 1, для каждой из частей массива
5. Результат работы алгоритма с первой частью записать в левую часть узла (```Node.Left```), а со второй - в правую часть


Таким образом, этот алгоритм возвращает корень двоичного дерева, построенного на основе массива токенов